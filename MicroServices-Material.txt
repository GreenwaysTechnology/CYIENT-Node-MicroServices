
Monolith:

-Technology first J2EE, Domain Next.


Team: OMS - PM- More PLS
1. DEV
2. TESTING
3. RELEASE
4. OPERATIONS


1.Req
2.Design
   High Level-UML,Database
   Low level - Runtime,databases,tools......
3.coding

-Vendor-lock in : Mono-lithic
   -DEV,TESTING,PRODUCTION.
-Work flow is highly sequencial
   Req -Complete
   Dev
   testing
   Release
   Production
  Delay in delivery:Cost increased
-Production cost was huge

Data Centers
 -need to purchase high powered servers - bare metal servers
 
Cost:
   -Hardware
   -OS -Linux-Ubuntu
   -Tools -Servers,databases etc....
   -Matrix Hell -  Mapping software components in dev and Production..


How to build enterprise jee based app.

App  must support a variety of different clients including desktop browsers. 

The application might also expose an API for 3rd parties to consume.

It might also integrate with other applications via a message broker. 

The application handles requests (HTTP requests and messages) by executing business logic; 

accessing a database; 

exchanging messages with other systems;

and returning a HTML/JSON/XML response. 

There are logical components corresponding to different functional areas of the application.

............................................................................................

IF App needs to talk to external systems like Message Brokers, other Systems like Main frames.

RPC/RPI
MOM
Connectors Arch.

BIZ LOGIC:

1- Service Layer : isloate service layer into separate component

 can be inside one app - one layer, that layer may run on different jvms -  distributed Arch.


Layer :

 Client ---- Web Layer  ----Service Layer ---- Repository Layer

/////////////////////////////////////////////////////////////////////////////////////////////

Packaging Model:
 
WAR - Web archive
EAR .

Problems with Single JAR/WAR:

1. Scalability
 Vertical scablitity
 Horzitional scability 

2.Deployments
    -Bare Metal Deployment

////////////////////////////////////////////////////////////////////////////////////////////
Monoloith distributed app development drabackbacks:

-Time is taken for project delivery
   -Requirements 
   -High level design and low level design
   -coding
   -testing
   -release
   -production- live

-Technology Stack and Vendor lock in
   -You need to build the entire app using one technology or one vendor product
    eg: J2EE, Oracle,Weblogic

-Production and maintance cost
  -You need to setup large data centers , you need to maintain them.

Companies like amzon,netflix,google wanted to change the app development model.
                                "Micro services"


Micro services are architural model of req,dev,test,relase,production,maintaince different ways.
    Continous req collecting
    Continous dev
    Continuous testing
    Continuous release
    Continuous deployment
    Using rented data centers: Cloud

-Domain First, Technology Next: Domain Driven Design.
-No Vendor lock- Multi tech stack.
-Indidual dev , deployment - orders is development ,tested,deployed,customers are developed,tested deployment.
   -Parrel dev.
-Automation -dev ops
   release - CI 
   deployment - Containerized - Docker..
-Introduction of Cloud computing
..............................................................................................

                                  Micro Services Design Pattern
..............................................................................................


Implementation Patterns:
........................

1.DOMAIN Models
  Decompose by biz features
  Decompose by sub domains

2.Development
  -Object oriented Design
 Class
      -Represent something in domain eg :Order,Customer
 Service
     -Offerings : giving something to somebody.
   A Program offers something - Data

Services can be broken into smllar and smallar based on domains
   Telecom domain :
       Telecommunication Services
		-Data Service
			- Mobile data
			- Broad Band
			    -Fiber
                            -leased Line
    
    FiberOpticService
        -getSpeed - 
        -increaseSpeed-
        -getNewConnection-
        -disconnectExisingConnection() 
        -payBills()    

   BillingService
	generateBill
	processPayment
	sendBill
        adjustBill
  
   How to design a Service? 
	USING SOLID Principles

  Single-responsibility principle -SRP

/////////////////////////////////////////////////////////////////////////////////////////////

Service Communications:
 
   Two Domains are going to collbrate each other to carry a biz transaction.


In Micro Services


FiberOpticService
     is 
   Running 
     inside
 One Application
       |
     Runtime
       |
  VM -Container

      OS
 
     |
     |   data
     |

Billing is Running
     is 
   Running 
     Another
 One Application
      |
     Runtime
       |
  VM -Container

      OS

Class ----will become  Objects

Object Communication === Service Communication



-SAME JVM(Runtime)
  Calling methods from one object(FiberDataService) to another object (BillingService).
-Different Runtime(JVM)
   -Networks - Protocals
    RestFull
      -HTTP 
   -RPC/RIP
	-ORB
        -RMI
        -gRpc
   -MOM - Message Brokers
        RabbitMQ
	Kaffka
	etc...
   -Event Bus
	-TCP

/////////////////////////////////////////////////////////////////////////////////////////////

Sevices Are Eagar or Lazy:
.........................
 

Eagar Service expects data immediatly.

Service waits for data until it is received.The service cant continue other jobs ; 

Sync Services

Drawbacks:

- Blocking 
    It leads performance issues

Service does not wait for data until it is received.The service t continue other jobs ; 

Async Services

Advantages
 - Non Blocking
    
Async Services Implementation:
..............................

Two ways:

1.Programmetic level 
    -Netty,webflux,Quarkus,Moleculre

2.Via Message Brokers
    RabbitMQ,Kafka


///////////////////////////////////////////////////////////////////////////////////////////

Service Failures:
.................

1.UnAvailability

2.Timeout due to slow calls

How to handle failures , how to return proper response to caller?

Reliability Design patterns :fault tolerance 

 -Circuit Breaker
 -Bulk Head
 -Rate Limiter
 -Retry
 -TimeLitmiter
 -Cache

///////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////

Service Communications in network and its Problems:
...................................................

Services are going to talk each other.

If they want to talk, What services should know each other?

 -Location
     ip address

In monolithic(traditional) deployment - ip address , ports are well known (hardcoded)
but in containers/ cloud env which are highly dynamic.

Where Micro services typically runs in a virtualized or containerized envs , locations are highly.

Services need to be registered some where and others services will ask registered location, that , hey give me that service

Service Registry and Discovery Pattern:
.......................................
Service Registry:
  -database - stores service informations

Service Discovery:
  locating services from the service registry

Types of Service discovery:
 -Client Side Service Discovery
 -Server Side Service Discovery
.............................................................................................
.............................................................................................

Data Management :

 A Service need to store data in data sources - Database
  
Database Per Service.

 FiberOpticService
Each service has its own schema. 
you can have more than one tables per service

Database: 
  Collection of tables,views,other objects

Shared Database:
  Sharing db for more than one services .
/////////////////////////////////////////////////////////////////////////////////////////////

Service Communication and Data Management

How to implement Transactions In Microservices?

It is very very difficult to implement and track transactions across multiple services.

Transactional Designpattern:

1.2PC  - 2 Phase Commit

2.Saga
    -EDA - Event Driven Architectures
  Saga Implementation
	-Choreography
        -Orchestration
//////////////////////////////////////////////////////////////////////////////////////////

.............................................................................................

Data Management :

 A Service need to store data in data sources - Database
  
Database Per Service.

 FiberOpticService
Each service has its own schema. 
you can have more than one tables per service

Database: 
  Collection of tables,views,other objects

Shared Database:
  Sharing db for more than one services .


Service Communication and Data Management

How to implement Transactions In Microservices?

It is very very difficult to implement and track transactions across multiple services.

Transactional Designpattern:

1.2PC  - 2 Phase Commit

2.Saga
    -EDA - Event Driven Architectures
  Saga Implementation
	-Choreography
        -Orchestration
//////////////////////////////////////////////////////////////////////////////////////////

Micro Services Management Patterns:

1.Log Managements
     Distributed/Centralized log management.
 
Tools:
   Graylog - mongodb,ES,Graylog
   ELK Stack  - ES,Logstash,kibana
   EFK Stack  - ES,Fluentd,Kibana


2.Application Metrics
     To monitor Application behaviours

Tools:
   Prometheus
   AWS Cloud Watch

3.Auditing
    User auditing,application auditing - Performance
    Record User activties in a databse

4.Distributed Tracing /Tracking
   If i want to track service calls
    A -->B ---C -- Something
   You can Track Exception Hierachies
  
 Open zipkin
 Open Tracing

5.Health Check Api
    To test health of apis,infra components.

 Some implemetations provides health endpoints where you can get helath metrics information
that can be feed to tools 

-Prometheus
.............................................................................................

////////////////////////////////////////////////////////////////////////////////////////////
				Micro Services - Implementations
............................................................................................

Microservices is langugage,platform,os independant. 

Java:
 -Spring Cloud
 -Quarkus
 -Light4J
 -Vertx
 etc...

Javascript : nodejs

-  Moleculer
-  Seneca
-  Loop back



                                   Moleculer

Progressive microservices framework for Node.js

Moleculer is framework which has implemented most of common microservices design patterns.

Moleculer features:

1.Promise-based solution (async/await compatible)
2.request-reply concept
3.support event driven architecture with balancing
4.built-in service registry & dynamic service discovery
5.load balanced requests & events (round-robin, random, cpu-usage, latency, sharding)
6.many fault tolerance features (Circuit Breaker, Bulkhead, Retry, Timeout, Fallback)
7.plugin/middleware system
8.support versioned services
9.support Streams
10.service mixins
11.built-in caching solution (Memory, MemoryLRU, Redis)
12.pluggable loggers (Console, File, Pino, Bunyan, Winston, Debug, Datadog, Log4js)
13.pluggable transporters (TCP, NATS, MQTT, Redis, NATS Streaming, Kafka, AMQP 0.9, AMQP 1.0)
14.pluggable serializers (JSON, Avro, MsgPack, Protocol Buffer, Thrift)
15.pluggable parameter validator
16.multiple services on a node/server
17.master-less architecture, all nodes are equal
18.parameter validation with fastest-validator
19.built-in metrics feature with reporters (Console, CSV, Datadog, Event, Prometheus, StatsD)
20.built-in tracing feature with exporters (Console, Datadog, Event, Jaeger, Zipkin)
21.official API gateway, Database access and many other modules…

https://moleculer.services/

Moleculer setup:

project creations;

1.from begining like normal node application.
2.moleculer cli- to setup realtime project with all artifacts.


1.create project from scratch.

create folder

mkdir microserviceapp

cd microservices/mkdir services

npm init
npm install moleculer
.............................................................................................
				Moleculer Architecture and Core concepts
.............................................................................................

1.Service:
  A Service is a simple java script module containing some part of a complex application.
  eg: UserService - contains information about users -  findAll users,save user,findBy,delete,update.
 It is isloated and self contained from the whole application, every service independant, meaning that even if the service goes offline or crashes the remaining services would be unaffected.

2.Node
   A node is simple os process(noderuntime). node may run local machine or external network.
   On a node one or more services are running.

3.Service Broker
   Service Broker is heart of moleculer.
   Service Broker is runtime for moleculer apps.
   Service Broker provides all infrastructure components - like    servicediscover,loadbalancer,network transporters,message bus .... 

4.Transporter
   Transporter is communication bus that services are used to communicate across the network
   It can transfer message,events,request,response....

5.GateWay
    API Gateway exposes exposes moleculer services to end users.
   if external system/uses who can communicate moleculer micro service apps via gate way only.

Services:

1.HTTP services
   Services are exposed for outsideworld

2.Back end services
   Services are used to encasulate biz logics like database operations,any biz

service names and file names:

math.service.js
hello.service.js

Create  Service Broker Object

const { ServiceBroker } = require('moleculer')

//ServiceBroker object creation
const broker = new ServiceBroker();

C:\session\CYIENT\microserviceapp>node services/first.service.js
[2021-07-24T06:13:08.387Z] INFO  laptop-r2tggfdl-20776/BROKER: Moleculer v0.14.16 is starting...
[2021-07-24T06:13:08.389Z] INFO  laptop-r2tggfdl-20776/BROKER: Namespace: <not defined>
[2021-07-24T06:13:08.389Z] INFO  laptop-r2tggfdl-20776/BROKER: Node ID: laptop-r2tggfdl-20776
[2021-07-24T06:13:08.390Z] INFO  laptop-r2tggfdl-20776/REGISTRY: Strategy: RoundRobinStrategy
[2021-07-24T06:13:08.391Z] INFO  laptop-r2tggfdl-20776/REGISTRY: Discoverer: LocalDiscoverer
[2021-07-24T06:13:08.398Z] INFO  laptop-r2tggfdl-20776/BROKER: Serializer: JSONSerializer
[2021-07-24T06:13:08.413Z] INFO  laptop-r2tggfdl-20776/BROKER: Validator: FastestValidator
[2021-07-24T06:13:08.415Z] INFO  laptop-r2tggfdl-20776/BROKER: Registered 13 internal middleware(s).
[2021-07-24T06:13:08.432Z] INFO  laptop-r2tggfdl-20776/$NODE: Service '$node' stopped.
[2021-07-24T06:13:08.433Z] INFO  laptop-r2tggfdl-20776/BROKER: ServiceBroker is stopped. Good bye.

First Service Creation
const { ServiceBroker } = require('moleculer')

//ServiceBroker object creation
const broker = new ServiceBroker();

//create Service : Service represents biz functionality.

broker.createService({
    name: 'first',
    actions: {
        sayFirst() {
            console.log('sayFirst is called')
            return 'I am First Micro Service'
        }
    }
})

//access/call service methods
function mainUsingPromises() {
    broker.start()
        .then(() => {
            console.log('Broker is ready!!')
            //invoke service
            broker.call('first.sayFirst')
                .then(res => {
                    console.log(res)
                })
                .catch(err => {
                    console.log(err);
                })
        })
        .catch(err => {
            console.log('Broker failed to start!!')
        });
}

async function main() {
    try {
       await broker.start();
       const res = await broker.call('first.sayFirst')
       console.log(res);
    }
    catch (err) {
        console.log(err);
    }
}
main();
............................................................................................

multi service on single broker:
const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();


broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello Service'
        }
    }
})


broker.createService({
    name: 'hai',
    actions: {
        sayHai() {
            return 'Hai Service'
        }
    }
})


broker.createService({
    name: 'welcome',
    actions: {
        sayWelcome() {
            return 'Welcome Service'
        }
    }
})

async function main() {
    try {
        await broker.start();
        const hello = await broker.call('hello.sayHello')
        const hai = await broker.call('hai.sayHai')
        const welcome = await broker.call('welcome.sayWelcome')
        console.log(`Hello Service : ${hello}`);
        console.log(`Hai Service : ${hai}`);
        console.log(`Welcome Service : ${welcome}`);

    }
    catch (err) {
        console.log(err);
    }
}
main();
.............................................................................................

Service Version:

 What if i have single service with various implementation over periods.

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();


broker.createService({
    name: 'hello',
    version: 1,
    actions: {
        sayHello() {
            return 'Hello Legacy'
        }
    }
})
broker.createService({
    name: 'hello',
    version: 2,
    actions: {
        sayHello() {
            return 'Hello new Feature'
        }
    }
})


async function main() {
    try {
        await broker.start();
        const helloV1 = await broker.call('v1.hello.sayHello')
        console.log(`Service Response : ${helloV1}`);
        const helloV2 = await broker.call('v2.hello.sayHello')
        console.log(`Service Response : ${helloV2}`);

    }
    catch (err) {
        console.log(err);
    }
}
main();
.............................................................................................

Multi Methods: A Service can have many methods:
...............................................

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();


broker.createService({
    name: 'greeter',
    version: 1,
    actions: {
        sayHello() {
            return 'Hello!!'
        },
        sayHai(){
            return 'Hai'
        },
        sayWelcome(){
            return 'Welcome';
        }
    }
})



async function main() {
    try {
        await broker.start();
        const hello = await broker.call('v1.greeter.sayHello')
        const hai = await broker.call('v1.greeter.sayHai')
        const welcome = await broker.call('v1.greeter.sayWelcome')
         console.log(`${hello} ${hai} ${welcome}`)
    }
    catch (err) {
        console.log(err);
    }
}
main();
........................................................................................

actions:
  Are used to represent methods.

Methods can be represented in two ways:

Way -1:
actions : {
 
  sayHello(){
     return 'hello'
  }

}

Way-2: you can add meta information to a methods

meta informations will discuss later.

actions: {
  
  sayHello: {
    
       handler(){
          
          return 'Hello'
           
       } 
  }

} 

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();


broker.createService({
    name: 'greeter',
    version: 1,
    actions: {
        sayHello: {
            handler() {
                return 'Hello'
            }

        },
        sayHai: {
            handler() {
                return 'Hai'
            }
        },
        sayWelcome: {
            handler() {
                return 'Welcome'
            }
        }
    }
})



async function main() {
    try {
        await broker.start();
        const hello = await broker.call('v1.greeter.sayHello')
        const hai = await broker.call('v1.greeter.sayHai')
        const welcome = await broker.call('v1.greeter.sayWelcome')
        console.log(`${hello} ${hai} ${welcome}`)
    }
    catch (err) {
        console.log(err);
    }
}
main();
..............................................................................................

Method args and Parameters:


broker.createService({
    name: 'hello',
    actions: {
        sayHello(ctx) {
            return 'Hello Service'
        }
    }
})

const hello = await broker.call('hello.sayHello',{name:'Subramanian'})

-Parameters must be encapsulated inside object only - {name:'subramanian'}

-Args must be received via one Object called "Context" Object

Context :

-it is proxy object for broker meaning that, similar broker.
-Most of the broker features are availble inside context object
-Context objects are created by moleculer automatically.
-We can grab context object reference inside actions method args
-Using context 
   -read parameters - ctx.params
   -you can call other service methods -  service communication. ctx.call
   -if you want to access broker information 

params Meta Data:

How to define meta information for service methods?

-validation
-caching
-fault info
-fallback
.....

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();


broker.createService({
    name: 'greeter',
    version: 1,
    actions: {
        sayHello(ctx) {
            // const name = ctx.params.name;
            const { name } = ctx.params;
            return `Hello ${name}`
        },
        sayHai: {
            //validation:
            params: {
                name: 'string'
            },
            handler(ctx) {
                const { name } = ctx.params;
                return `Hai ${name}`
            }
        }
    }
})



async function main() {
    try {
        await broker.start();
        const hello = await broker.call('v1.greeter.sayHello', { name: 'Subramanian' })
        const hai = await broker.call('v1.greeter.sayHai', { name: 'Subramanian' })
        console.log(`${hello} ${hai}`)

        //with other type
        const res = await broker.call('v1.greeter.sayHai', { name: 123 })
    }
    catch (err) {
        console.log(err);
    }
}
main();
//////////////////////////////////////////////////////////////////////////////////////////////

Service Creation in a file and how to export,start that service


services/math.service.js

module.exports = {
    name: 'math',
    actions: {
        add: {
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params
                return a + b;
            }

        }
    }
};

services/main.service.js

const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker();


async function main() {
    broker.loadService('./services/math.service');
    //loading multiple services
    //broker.loadServices(folder="services",fileMask="**/*.service")
    //load all services from the current loader
    //broker.loadServices("./")

    try {
        await broker.start()
        const res = await broker.call('math.add', { a: 10, b: 10 })
        console.log(res);
    }
    catch (err) {
        console.log(err);
    }

}
main();

Service Creation and loading via moleculer runner:

moleculer-runner is tool used for loading services and for automation.

moleculer is distributed as dev dependency, so have to use via scripts only.


services/math.service.js
module.exports = {
    name: 'math',
    actions: {
        add: {
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params
                return a + b;
            }

        }
    }
};

services/entry.service.js

const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker();

broker.createService({
    name: 'entry'
})

async function main() {
    broker.loadService('./services/math.service');
    try {
        await broker.start()
        const res = await broker.call('math.add', { a: 10, b: 10 })
        console.log(res);
    }
    catch (err) {
        console.log(err);
    }

}
main();

package.json
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
     "dev" : "moleculer-runner ./services/entry.service.js"
  },
/////////////////////////////////////////////////////////////////////////////////////////////

Service Methods:

1.public methods
  methods are accssiable outside 
2.private methods
  methods are not accssible outside
  methods are used to isloate complex logic from public methods.


const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker();

broker.createService({
    name: 'calculator',
    //public methods
    actions: {
        add(ctx) {
            const { a, b } = ctx.params;
            const result = this.addNumbers(a, b);
            return result;
        },
        substract(ctx) {
            const { a, b } = ctx.params;
            const result = this.substractNumbers(a, b);
            return result;
        },
    },
    //private methods
    methods: {
        addNumbers(a, b) {
            return a + b;
        },
        substractNumbers(a, b) {
            return a - b;
        }
    }
})


async function main() {
    try {
        await broker.start()
        const res = await broker.call('calculator.add', { a: 10, b: 10 })
        console.log(res);
        const res1 = await broker.call('calculator.substract', { a: 10, b: 2 })
        console.log(res1);

    }
    catch (err) {
        console.log(err);
    }

}
main();
/////////////////////////////////////////////////////////////////////////////////////////////

REPL: READ Evaulate Print Loop:
- interactive command line tool, used for testing application.

node provides REPL
node

Moleculer provides REPL Prompt for testing services interactivly.

services/math.service

const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {
        add: {
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params
                return a + b;
            }

        }
    }
});

async function main() {
    try {
        await broker.start()
        broker.repl();        
    }
    catch (err) {
        console.log(err);
    }

}
main();



npm install moleculer-repl --save-dev

>node services/repl.service.js
[2021-07-24T09:34:52.394Z] INFO  laptop-r2tggfdl-6988/BROKER: Moleculer v0.14.16 is starting...
[2021-07-24T09:34:52.396Z] INFO  laptop-r2tggfdl-6988/BROKER: Namespace: <not defined>
[2021-07-24T09:34:52.397Z] INFO  laptop-r2tggfdl-6988/BROKER: Node ID: laptop-r2tggfdl-6988
[2021-07-24T09:34:52.398Z] INFO  laptop-r2tggfdl-6988/REGISTRY: Strategy: RoundRobinStrategy
[2021-07-24T09:34:52.399Z] INFO  laptop-r2tggfdl-6988/REGISTRY: Discoverer: LocalDiscoverer
[2021-07-24T09:34:52.407Z] INFO  laptop-r2tggfdl-6988/BROKER: Serializer: JSONSerializer
[2021-07-24T09:34:52.419Z] INFO  laptop-r2tggfdl-6988/BROKER: Validator: FastestValidator
[2021-07-24T09:34:52.421Z] INFO  laptop-r2tggfdl-6988/BROKER: Registered 13 internal middleware(s).
[2021-07-24T09:34:52.440Z] INFO  laptop-r2tggfdl-6988/REGISTRY: '$node' service is registered.
[2021-07-24T09:34:52.443Z] INFO  laptop-r2tggfdl-6988/REGISTRY: 'math' service is registered.
[2021-07-24T09:34:52.443Z] INFO  laptop-r2tggfdl-6988/$NODE: Service '$node' started.
[2021-07-24T09:34:52.444Z] INFO  laptop-r2tggfdl-6988/MATH: Service 'math' started.
[2021-07-24T09:34:52.445Z] INFO  laptop-r2tggfdl-6988/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 13ms.
mol $ help

  Commands:

    help [command...]                                          Provides help for a given command.
    q                                                          Exit application
    actions [options]                                          List of actions
    bench [options] <action> [jsonParams] [meta]               Benchmark a service
    broadcast <eventName>                                      Broadcast an event
    broadcastLocal <eventName>                                 Broadcast an event locally
    cache keys [options]                                       List keys of cache entries
    cache clear [pattern]                                      Clear cache entries
    call [options] <actionName> [jsonParams] [meta]            Call an action
    dcall [options] <nodeID> <actionName> [jsonParams] [meta]  Direct call an action
    clear [pattern]                                            Clear cache entries
    cls                                                        Clear console
    destroy <serviceName> [version]                            Destroy a local service
    emit <eventName>                                           Emit an event
    env                                                        List of environment variables
    events [options]                                           List of event listeners
    info                                                       Information about broker
    load <servicePath>                                         Load a service from file
    loadFolder <serviceFolder> [fileMask]                      Load all services from folder
    metrics [options]                                          List metrics
    nodes [options]                                            List of nodes
    services [options]                                         List of services

mol $


Services:

-admin service
   services for monitoring moleculer application
$node

-application services
math,customer,user

call math.add --a 10 --b 20
>> Call 'math.add' with params: { a: 10, b: 20 }
>> Execution time:592μs
>> Response:
30
mol $ call math.add --a 10 --b 30
>> Call 'math.add' with params: { a: 10, b: 30 }
>> Execution time:653μs
>> Response:
40
mol $ call math.add --a 10 --b 390
>> Call 'math.add' with params: { a: 10, b: 390 }
>> Execution time:473μs
>> Response:
400
mol $ call math.add --a 100 --b 390
>> Call 'math.add' with params: { a: 100, b: 390 }
>> Execution time:551μs
>> Response:
490
............................................................................................
					Service Communication
............................................................................................

Types of services:

1.Back End Services
2.Http Services

Two types of services based on communication.
1.local service

2.remote service

Back End Service Communication:
...............................
1.local service : 

 if services are running on single /same node/single broker - local services


const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker();

//local services

broker.createService({
    name: 'math',
    actions: {
        add: {
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params
                //invoke services
                return ctx.call('adder.add', { a: a, b: b });
            }

        }
    }
});


broker.createService({
    name: 'adder',
    actions: {
        add: {
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params
                return a + b;
            }

        }
    }
});

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();
.............................................................................................
					Remote Services
...............................................................................................

Steps:

1.Create two services

2.Run two services in a separate command prompt.

3.See the output

services/remote1.service.js
const { ServiceBroker } = require('moleculer');
const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {
        add: {
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params
                //invoke services
                return ctx.call('adder.add', { a: a, b: b });
            }

        }
    }
});

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();

services/remote2.service.js

    const { ServiceBroker } = require('moleculer');

    const broker = new ServiceBroker();

    broker.createService({
        name: 'adder',
        actions: {
            add: {
                params: {
                    a: 'number',
                    b: 'number'
                },
                handler(ctx) {
                    const { a, b } = ctx.params
                    return a + b;
                }

            }
        }
    });

    async function main() {
        try {
            await broker.start()
            broker.repl();
        }
        catch (err) {
            console.log(err);
        }

    }
    main();

open two cmd
>node services/remote1.service.js
>node services/remote2.service.js

from remote1.service.js , invoke method from repl
 call math.add --a 10 --b 20
>> Call 'math.add' with params: { a: 10, b: 20 }
[2021-07-24T10:01:27.768Z] WARN  laptop-r2tggfdl-11112/BROKER: Service 'adder.add' is not registered.
>> ERROR:
ServiceNotFoundError: Service 'adder.add' is not found.
    at ServiceBroker.findNextActionEndpoint (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\service-broker.js:1034:13)
    at ServiceBroker.call (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\service-broker.js:1083:26)
    at Context.call (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\context.js:289:23)
    at Service.handler (C:\session\CYIENT\microserviceapp\services\remote1.service.js:15:28)
    at C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\utils.js:185:22
    at processCheckResponse (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\validators\base.js:66:12)
    at validateContextParams (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\validators\base.js:84:15)
    at ServiceBroker.timeoutMiddleware (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\middlewares\timeout.js:35:14)
    at ServiceBroker.fallbackMiddleware (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\middlewares\fallback.js:29:11)
    at ServiceBroker.errorHandlerMiddleware (C:\session\CYIENT\microserviceapp\node_modules\moleculer\src\middlewares\error-handler.js:14:10)
Data:  { action: 'adder.add' }


-The moleculer not able to find out service from the local node, since it is running remotly
.............................................................................................
				Networking
............................................................................................



In order to communicate with other nodes(serviceBrokers) you need to configure a transfer.


Transporters:

-Transporter is an important module if you are running services on multiple nodes. 

-Transporter communicates with other nodes. 

-It transfers events, calls requests and processes responses …etc. 

-If a service runs on multiple instances on different nodes, the requests will be load-balanced among live nodes.

Transports:
............

Built-in transporters

TCP transporter
NATS Transporter
Redis Transporter
MQTT Transporter
AMQP Transporter
Kafka Transporter
NATS Streaming (STAN) Transporter


Steps;

1.you have to run Transporter broker software

 like redis server or nats server ,AMQP server.....

NATS: Bridge :https://nats.io/download/

docker run  --name nats-main -d -p 4222:4222 -p 6222:6222 -p 8222:8222 nats 


2.you have to install transport adapter/driver

npm install nats@1.4.12 --save

3.Configure Service Broker with Transport

services/remote1.service.js
const { ServiceBroker } = require('moleculer');


const broker = new ServiceBroker({
    transporter:'nats://localhost:4222'
});

broker.createService({
    name: 'math',
    actions: {
        add: {
            params: {
                a: 'number',
                b: 'number'
            },
            handler(ctx) {
                const { a, b } = ctx.params
                //invoke services
                return ctx.call('adder.add', { a: a, b: b });
            }

        }
    }
});

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();


services/remote2.service.js

    const { ServiceBroker } = require('moleculer');

    const broker = new ServiceBroker({
         nodeID:'Cyient-Server-2',
         transporter:'nats://localhost:4222'
    });

    broker.createService({
        name: 'adder',
        actions: {
            add: {
                params: {
                    a: 'number',
                    b: 'number'
                },
                handler(ctx) {
                    const { a, b } = ctx.params
                    return `${a + b} - ${broker.nodeID}`;
                }

            }
        }
    });

    async function main() {
        try {
            await broker.start()
            broker.repl();
        }
        catch (err) {
            console.log(err);
        }

    }
    main();


>node services/remote1.service.js


>> Call 'math.add' with params: { a: 10, b: 20 }
>> Execution time:13s
>> Response:
'30 - laptop-r2tggfdl-13600'
mol $ call math.add --a 10 --b 20
>> Call 'math.add' with params: { a: 10, b: 20 }
>> Execution time:4ms
>> Response:
'30 - Cyient-Server-2'
mol $ call math.add --a 10 --b 20
>> Call 'math.add' with params: { a: 10, b: 20 }
>> Execution time:4ms
>> Response:
'30 - Cyient-Server-2'
mol $ call math.add --a 10 --b 200
>> Call 'math.add' with params: { a: 10, b: 200 }
>> Execution time:3ms
>> Response:
'210 - Cyient-Server-2'
mol $ call math.add --a 10 --b 20000
>> Call 'math.add' with params: { a: 10, b: 20000 }
>> Execution time:3ms
>> Response:
'20010 - Cyient-Server-2'
mol $ call math.add --a 10 --b 20000
>> Call 'math.add' with params: { a: 10, b: 20000 }
>> Execution time:3ms
>> Response:
'20010 - Cyient-Server-2'
mol $
.............................................................................................
				HTTP Services
..............................................................................................

if you wanto build HTTP based services(rest apis), molculer core lib has no apis.

We need to go with modules. Molculur provides modules in order to extend the basic moleculr application.

Modules:
-API Gate Module -  Web
-Databases and Stores 
-Micro services management
  -Mertics and Tracing
-Secuirty
-Validation
etc........

-API Gate Module -  Web 
moleculer-web:

 official API Gate way module for Moleculer Framework

Features:
-support for http and https
-serve static files
-router supports
-file upload support
-alias names
-whitelist
-multiple body parsers-json,urlencoded
-cors
-Etags
-RateLimitter
-streaming support
etc....
...............................................................................................
				Service inheritance

Objective:

 lets say i have a service having more methods, that i dont want to give in a service
 i have service , that service apis , i want to reuse in service apis.

Service inheritance comes into place.

In molecular , a service can inherit many services - multi level, for multi level, molcular uses a concept called "mixins".

mixins is a design pattern used in javascript to implement multi level inheritance like java uses interfaces.


Use case:
1.if you write any REST Controller.
2.if you write database operations inside your service.


How to write services in a different file

How to do inheritance(service mixins) - mixin means multilevel 


services/parent.service.js

//service is exported
module.exports = {
    name: 'hello',
    actions: {
        //define biz api of that service
        sayHello() {
            return 'Hello,Moleculer'
        }
    }
};

services/child.service.js
const { ServiceBroker } = require('moleculer');
const hello = require('./parent.service');
const { log } = console;
const broker = new ServiceBroker();

broker.createService({
    name: 'greeter',
    mixins: [hello], //service inheritance done
    actions: {
        sayGreet(){
            return 'Hai'
        }
    }
})
async function init() {
    try {
        await broker.start();
        let response;
        response = await broker.call('greeter.sayHello')
        log(`${response}`)
        response = await broker.call('greeter.sayGreet')
        log(`${response}`)

    }
    catch (e) {
        log(e);
    }
}
init();
...............................................................................................

Steps to integrate Moleculer-Web

-npm install moleculer-web --save



services/firstrest.service.js
const { ServiceBroker } = require('moleculer');
const ApiGateWay = require('moleculer-web');
const USERS = require('../mock-data/users')

const broker = new ServiceBroker();

//back end services

//http://localhost:3000/servicename/methodname
//http://localhost:3000/greeter/sayHello

broker.createService({
    name: "greeter",
    actions: {
        sayHello() {
            return "Hello"
        }
    }
})

//json 
//http://localhost:3000/users/list
broker.createService({
    name: "users",
    actions: {
        list() {
            return USERS
        }
    }
})


//

broker.createService(ApiGateWay)


async function main() {
    await broker.start();
}
main();

..............................................................................................

How to override web settings?

const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const USERS  =require('../mock-data/users')

const broker = new ServiceBroker({
    hotReload : true
});

//back end service
broker.createService({
    name: "greeter",
    actions: {
        sayHello() {
            return "Hello"
        }
    }
})

broker.createService({
    name: "users",
    actions: {
        list() {
            return USERS
        }
    }
})

//Frond End Service
//entry url configuration and action configuration - frond to back end configuration

broker.createService({
    name: 'ApiGateWayService',
    mixins: [ApiGateWayService],
    settings: {
        routes: [
            {
                path: "/api"

            }
        ]
    }
})



async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();

..............................................................................................

Whitelist:
 To restrict what actions can be accessed inside service or not

const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const USERS  =require('../mock-data/users')

const broker = new ServiceBroker({
    hotReload : true
});

//back end service
broker.createService({
    name: "greeter",
    actions: {
        sayHello() {
            return "Hello"
        },
        sayWelcome(){
            return 'Welcome'
        },
        sayHai(){
            return 'Hai'
        }

    }
})

broker.createService({
    name: "users",
    actions: {
        list() {
            return USERS
        }
    }
})

//Frond End Service
//entry url configuration and action configuration - frond to back end configuration

broker.createService({
    name: 'ApiGateWayService',
    mixins: [ApiGateWayService],
    settings: {
        routes: [
            {
                path: "/api",
                whitelist: [
                    //Restrict to access only sayHello action
                    "greeter.sayHello",
                    //Restrict to access all actions in Greeter service
                    //"greeter.*"
                ]               
            }
        ]
    }
})



async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();
////////////////////////////////////////////////////////////////////////////////////////////

URL Mapping in moleculer:

http://localhost:3000/api/serviceName/actionName
  This is not good way to map urls , which more difficult to remember, it is not user friendly
it is not even secure,the reason, we expose the back service to end users.

Aliases:
........
  You can use aliases(dummyname/fakename)-Virtual path, instead of action name.

 settings: {
        routes: [
            {
                path: "/api",
                aliases: { 

                    "hello" : "greeter.hello",
                    "users" :  "users.list"
                }             
            }
        ]

http://localhost:3000/api/hello
http://localhost:3000/api/users

const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const USERS = require('../mock-data/users')

const broker = new ServiceBroker();

//back end service
broker.createService({
    name: "greeter",
    actions: {
        sayHello() {
            return "Hello"
        },
        sayWelcome() {
            return 'Welcome'
        },
        sayHai() {
            return 'Hai'
        }

    }
})

broker.createService({
    name: "users",
    actions: {
        list() {
            return USERS
        }
    }
})

//Frond End Service
//entry url configuration and action configuration - frond to back end configuration

broker.createService({
    name: 'ApiGateWayService',
    mixins: [ApiGateWayService],
    settings: {
        routes: [
            {
                path: "/api",
                aliases: {
                    "hello": "greeter.sayHello",
                    "hai": "greeter.sayHai",
                    "welcome": "greeter.sayWelcome",
                    "users": "users.list"
                }
            }
        ]
    }
})

async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();











